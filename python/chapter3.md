# 函数
通过接口，与外界通信，传递信息。
- ```function_name([paramter_list])```他的参数传递形式是怎么样的？
它实际上是 **“对象共享”**
- 函数返回值：如果没有返回值，就会自动返回 **none**
- 基本调用逻辑
  他只能调用解释器已经知道的函数；

### 3.13 内置函数
- ```all(iterable)```
  如果iterable全部元素为ture，则为true
- ```any(iterable)```
  iterable某个true，则为true。
- ``` callable(object)```
  若 **object** 可以被调用，则返回true。
- ```chr(i)```
  返回整数i表示的unicode字符对用的字符串
  - ord函数时它的逆运算
- ```eval()函数似乎没有什么印象```（指表达式求值）
- ```map(function,iterable)```
  类似于c++中的，将function作用到iterable的每个元素上。
- ```repr(object)```
  返回object的可打印字符串表示。

## 3.2
### 3.2.1
- 函数调用实例
```python
def fib(n):
    a,b = 0,1
    while a < n:
        print(a, end = ' ')
        a , b =b ,a + b
        print()
fib(6)
```
- 函数定义时允许互相使用，因为定义不是调用.但是在实际调用f时，g得先定义过。
```python
def f():
  print("f")
  g()
def g():
  print(g)
  f()
```
- 嵌套函数（不是c意义上的互相调用）
  ``` python
  def f():
    print("f")
    def g():
      print("g")
    g()
  
  f()#合理调用
  f.g()#不合法，g是外界无法看到的，只能在f函数里面使用，类似于私有成员
  ```
  但是，在下面的情况可以：
  ```
- 嵌套函数（不是c意义上的互相调用）
  ``` python
  def f():
    print("f")
    def g():
      print("g")
    return g

   h = f() #现在h是g（）函数
   h()  #==g()
   #甚至下面的这个也合法
   f()()
  
  f()#合理调用
  f.g()#不合法，g是外界无法看到的，只能在f函数里面使用，类似于私有成员
  ```
- 函数对象类型
  ```python
  f = fib
  f(1000)
  fib(1000)
  ```
  现在相当于函数也是数据，赋值给f，f就可以直接当做函数来用了
  值得注意的是，一般的return是直接终止的，但是在```try-finally-```限制性finally，再return。

### 3.2.3 Lambda表达式
```python
def function(para_list):
  return expression
#等价于
lambda[para_list]:expression
```
相当于创建了一个匿名函数，返回函数对象，适用于需要简单函数的部分，需要注意的是 **它本身不是表达式，虽然感觉上很像表达式的作用
```python
f = lambda a,b : a + b  #取个别名
print(type(f)) #class function
```

### 3.2.4 函数标注
提供用户自定义函数所使用的的类型原信息
- 函数标注格式
  参数使用“ ：”来标注，返回值用“ ->”来标注
  ```python 
  def Add(x:int,y:int = 0) ->int:#还可以看到缺省值。
  return x + y
  ```
## 3.3名空间与作用域
### 3.3.1名空间
名空间： 从名称到对象的映射
- 大多数名空间表现为符号表，以字典的形式，变量存储其中
- **<font color=plum>标识符独立性</font>**：不同名空间的同名标识符没有任何关联
- **<font color=plum>标识符唯一性</font>**：统一名空间中的标识符不重名
- **<font color=plum>名空间嵌套</font>**：名空间可以包含(比如类成员函数的定义等)
分类
- 内置名空间：python自带的初始的名空间。
- 全局名空间：模块内部的全局名称集合
- 局部名空间：
- 函数名空间：调用和结束时创建和删除名空间
- 类名空间：创建时间：构造对象。删除时间：销毁对象时，也就是说，这个空间是不断创建和删除的。
- 名解析：“.”属性操作符解析不同名空间中的标识符。
```python
e=1
print(e)#1
import math;
print(e,math.e)#不冲突
#但是如果from math inport e;就会冲突
```
### 3.3.2作用域
定义：可访问名空间标识符的文法区域（在某一程序处能否使用这个名空间的这个标识符问题）
- 作用域分类
  - 局部作用域：函数，类，等
  - 全局作用域；主模块```_main_```
  - 内置作用域
- 局部量：函数，类，lambda表达式中的量。
- 全局量： 局部之外的
  - 问题：如何在函数里修改全局变量的值？（因为即使在全局定义了n，函数里写n也认为是函数自己内部的）
  解决：声明！！
  - 全局声明 global
  ```python
  n = 42
  def nn():
    global n
    n = n * 2
    return n
  #在整个函数中用的都是全局的n
  ```
  - 非局部声明（比如中间一层的量）
  nonlocal 声明（只能是倒数第二层，如果4层的话正数第二层是找不到的）
  ## 3.4函数参数
  - 形式参数与实际参数
  - 参数传递：是共享机制，不是值传递，类似于指针？
  - 参数缺省值
  ```def multiply(x,time=2):return x*time```
  缺省值参数一般写在最后，有多位时实际传递时不能跳过某一个缺省值。
  缺省值技术可以实现函数重载效果（实际上就是多个不同函数，只是参数不同允许重名而已）
  ### 3.4.3
  - 位置参数
   位置固定，参数传递是按照顺序传递
  - 关键字参数
  可以实现参数缺省值的跨越,同样，缺省的擦拿书要位于位置参数之后
  ``` python
  def f(x,y=1,z=1):
    return x
  f(a,z=3)#这样调用，y就默认为缺省值了666
  ```

## 3.5
### 3.5.1递归函数

```python
def fact(n=1):
  if n<=1:
    return 1
  r,i=1,2
  while i<=n:
    r *= i
    i += 1
  return r

def fact2(n):
  return n*fact(n-1) if n>1 else 1
  #这就是各阶乘，就是n的复杂度
def fib(n):
  if n <= 1:
    return 1;
  i = 2
  while i < n:
    a ,b = b ,a+b;
    i+=1
  return b
def fib2(n):
  return fib2(n)+fib(n-1) if n > 1 else n
  ```
  递归就是在理解上更容易，理论上，任何递归程序都可以使用循环迭代方法解决（感觉上只是针对于尾递归吧）
  ### 3.5.2 递归信任
  - 检查最简单的情况是否有考虑（或者是最初始的情况，比如fib的n=1，这种）
  - 最减轻情形要能顺利返回（就是判断的依据）
  - 递归分解是否变简单了
  - 递归最终是否能够回到最简单（最简单）情形
  - 子问题与原来的问题得一样（问题只有蚕食规模变小了，就是一层一层得是一个问题，或者一个操作
  - 子问题要合理组装


## 3.6 模块
### 3.6.1模块
模块：
- 定义，包含python定义和语句的文本文件
- 名称：模块文件名，不包含.py
- 在模块内部，使用全局变量__name__获得模块名称
包：
定义：包含__path__属性的模块集合
库：

模块语句
- 目的：主要用于初始化模块
- 执行时间：导入语句首次解析模块名称时。
  全局变量
  目的：在模块内部定义的量，主要用于描述模块状态
函数定义：
目的，代码复用

**<font color=plum>这一部分回去好好看看吧</font>**

### 3.6.2日期时间
- 日期时间模块 datetime
  - 功能：日期和时间处理
  - 日期时间对象分类
  ```python
  datetime.MINYEAR